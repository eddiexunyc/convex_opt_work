{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"DATA 609 - Homework 4: Convex Functions\"\n",
        "format: html \n",
        "editor: source\n",
        "author: Eddie Xu\n",
        "---\n",
        "\n",
        "\n",
        "## Instructions\n",
        "\n",
        "Please submit a .qmd file along with a rendered pdf to the Brightspace page for this assignment. You may use whatever language you like within your qmd file, I recommend python, julia, or R. \n",
        "\n",
        "## Problem 1: (Exercise 3.2 in CVX Book) \n",
        "\n",
        "(a) The figure below shows three levels sets for a function $f$. The value of the function on the level set is indicated by the number next to each curve. For example, the curve labeled $1$ corresponds to the points $\\mathbf{x}\\in\\mathbb{R}^2$ satisfying $f(\\mathbf{x}) = 1$. \n",
        "\n",
        "Determine whether it is possible for the function $f$ to be convex, concave, quasiconvex, or quasiconcave. Give a brief justification for your answer.\n",
        "\n",
        "Note: it may be that several options are possible, that one is possible, or that none at all are.\n",
        "\n",
        "![Level Curves of $f$](lab4_fig1a.png){width=40%}\n",
        "\n",
        "### Problem 1(a) Solution\n",
        "\n",
        "The first function appears to be a quasiconvex or convex because the sublevel sets appear to be convex. It is definitely not concave or quasiconcave because the superlevel sets appears not to be convex.\n",
        "\n",
        "(b) The figure below shows level sets for a different function $g$. Again determine whether it is possible for the function $g$ to be convex, concave, quasiconvex, or quasiconcave. Note: it may be that several options are possible, that one is possible, or that none at all are.\n",
        "\n",
        "![Level Curves of $g$](lab_fig1b.png){width=40%}\n",
        "\n",
        "### Problem 1(b) Solution\n",
        "\n",
        "For this funcion, it appears not to be convex, concave, quasiconvex, or quasiconcave. The reason why the the sublevel sets appears not to be convex. \n",
        "\n",
        "## Problem 2: (CVX Book Extended Exercises 3.1)\n",
        "\n",
        "Determine the curvature of the functions below. Your responses can be affine, convex, concave, or none (meaning not convex or concave). Provide a brief justification\n",
        "\n",
        "(a) $f(x) = \\min(2,x,\\sqrt{x})$ with $\\mathbf{dom} f = \\{x\\,|\\, x\\geq 0\\}$ (i.e. $\\mathbb{R}_+$)\n",
        "(b) $f(x) = x^3$, with  $\\mathbf{dom} f = \\mathbb{R}$ \n",
        "(c) $f(x) = x^3$, with   $\\mathbf{dom} f = \\{x\\,|\\, x\\geq 1\\}$\n",
        "(d) $f(x,y) = \\sqrt{x\\min(y,2)}$, with $\\mathbf{dom} f = \\{(x,y)\\,|\\, x\\geq 0\\, , y\\geq 0\\}$ (i.e. $\\mathbb{R}^2_+$)\n",
        "(e) $f(x,y) = \\left(\\sqrt{x} +\\sqrt{y}\\right)^2$ with $\\mathbf{dom} f = \\{(x,y)\\,|\\, x\\geq 0\\,,\\, y\\geq 0\\}$ (i.e. $\\mathbb{R}^2_+$)\n",
        "\n",
        "### Problem 2 Solution\n",
        "\n",
        "(a) This function is convex on $\\mathbb{R}_+$ because 2 and x are affline functions and the second derviative of $\\sqrt{x}$ is concave.\n",
        "(b) This function is not convex or concave because the second derivative of $x^3$ can be negative, positive or zero.\n",
        "(c) This function is convex because the second derivative of $x^3$ is positive when $x\\geq 1\\}$.\n",
        "(d) This function is concave because the $\\sqrt{x}$ is concave for when x is positive or zero and the $\\sqrt{min(y,2)}$ is concave when y is positive or zero.\n",
        "(e) This function is convex because the square of a sum of $\\sqrt{x} +\\sqrt{y}$ is convex, therefore the square of that will be convex as well.\n",
        "\n",
        "## Problem 3: (Selected from CVX Book Extended Exercises 3.51-3.52)\n",
        "\n",
        "For each of the following problems implement the following functions using Disciplined Convex Programming and CVX, \n",
        "and use CVX to verify that they are convex\n",
        "\n",
        "(a) $f(x,y) = \\frac{1}{xy}$, with $\\mathbf{dom} f = \\mathbb{R}^2_{++}$. Hint: Use the Atoms listed below part (b) as well as addition, subtraction, and scalar multiplication. \n",
        "There are multiple ways to solve this problem.\n",
        "\n",
        "### Problem 3(a) Solution\n"
      ],
      "id": "64393f2d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import cvxpy as cp\n",
        "\n",
        "# define both variables which need to be positive\n",
        "x = cp.Variable(pos=True)  \n",
        "y = cp.Variable(pos=True)\n",
        "\n",
        "# Define the function f(x, y) = 1 / (x * y)\n",
        "z = cp.multiply(x, y)  \n",
        "f_xy = cp.inv_pos(z)\n",
        "\n",
        "# miniminze and set up the problem\n",
        "objective = cp.Minimize(f_xy)\n",
        "problem = cp.Problem(objective)\n",
        "\n",
        "# solve the problem following DCP rules\n",
        "problem.solve(gp=True)\n",
        "\n",
        "# Output the solution for x, y, and the function value\n",
        "print(f'The Optimal x is {x.value} and the optimal y is {y.value}.')\n",
        "print(f\"f(x, y) = {f_xy.value}\")"
      ],
      "id": "dcc3296a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "(b) $f(x,y) = \\sqrt{1+\\frac{x^2}{y}}$, with $\\mathbf{dom} f = \\mathbb{R}\\times\\mathbb{R}_{++}$ (this means $x$ is any real number and $y$ is strictly greater than 0. \n",
        "\n",
        "### Problem 3(b) Solution\n"
      ],
      "id": "ccce61b7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# load packages\n",
        "import cvxpy as cp\n",
        "import numpy as np\n",
        "\n",
        "# define variables\n",
        "x = cp.Variable() \n",
        "y = cp.Variable(pos=True) \n",
        "\n",
        "# define the function f(x, y) = sqrt(1 + x^2 / y)\n",
        "z = cp.quad_over_lin(x, y)\n",
        "f = cp.sqrt(1 + z)\n",
        "\n",
        "# solve\n",
        "problem = cp.Problem(cp.Minimize(f))\n",
        "# problem.solve(qcp=True)\n",
        "\n",
        "# print\n",
        "print(f\"Optimal x: {x.value}\")\n",
        "print(f\"Optimal y: {y.value}\")\n",
        "print(f\"Objective value: {f.value}\")"
      ],
      "id": "fe73f9dd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Hint: The following atoms may be helpful, there are multiple ways to solve this problem.\n",
        "\n",
        "- `inv_pos(u)`, which is $1/u$, with domain $\\mathbb{R}_{++}$\n",
        "- `square(u)`, which is `u^2` , with domain $\\mathbb{R}$\n",
        "- `sqrt(u)`, which is $\\sqrt{u}$, with domain $\\mathbb{R}_+$\n",
        "- `geo_mean(u,v)`, which is $\\sqrt{uv}$, with domain $\\mathbb{R}^2_+$\n",
        "- `quad_over_lin(u,v)`, which is $u^2/v$, with domain $\\mathbb{R} \\times \\mathbb{R}_{++}$\n",
        "- `norm2(u,v)`, which is $\\sqrt{u^2 + v^2}$ , with domain $\\mathbb{R}^2$.\n",
        "\n",
        "## Problem 4: Periodic Poisson Regression to predict Car Crashes\n",
        "\n",
        "For this problem, we will be working with the dataset [manhattan_crashes.csv](https://media.githubusercontent.com/media/georgehagstrom/DATA609Spring2025/refs/heads/main/website/assignments/labs/labData/manhattan_crashes.csv), which contains a time series of the number of car crashes occurring in Manhattan every hour for a period of time.\n",
        "\n",
        "Here we will develop a Poisson regression model to predict rate of crashes during each time of day. \n",
        "\n",
        "(a) Consider the following statistical model for the number of crashes $N_i$ during hour $i$ of a given day.\n",
        "\n",
        "$$\n",
        "N_i \\sim \\exp(-\\lambda_i)\\frac{\\lambda_i^{N_i}}{{N_i}!}\n",
        "$$\n",
        "\n",
        "where $i$ ranges from $0$ to $23$ and corresponds to the hour of the day. Suppose that we have a dataset of counts for crashes where $C_{ni}$ is the number of crashes that occur in the $i$th hour of the $n$th day. Then the `log` likelihood function for the parameters $\\lambda$ is:\n",
        "\n",
        "$$\n",
        "- \\log(p(C|\\lambda)) = \\sum_{n=1}^N \\sum_{i=0}^{23} \\left( \\lambda_i - C_{ni}\\log(\\lambda_i) + \\log(C_{ni}!)\\right) \n",
        "$$\n",
        "\n",
        "However, we can drop terms terms that don't depend on $\\lambda$ because they will have no impact on the maximum likelihood solution. This lets us form a simpler objective function:\n",
        "\n",
        "$$\n",
        "L(C|\\lambda) = \\sum_{n=1}^N\\sum_{i=0}^{23} \\left(\\lambda_i - C_{ni}\\log(\\lambda_i)\\right)\n",
        "$$\n",
        "or if we use matrix-vector notation:\n",
        "\n",
        "$$\n",
        "L(C|\\lambda) = N\\mathbf{1}^T\\lambda - \\mathbf{1}^T C \\log(\\lambda)\n",
        "$$\n",
        "\n",
        "where $\\log(\\lambda)$ is interpreted as a vector whose $i$th entry is $\\log(\\lambda_i)$ and the vector $\\mathbf{1}^T$ has all entries equal to $1$ and has the right dimension in each case to make the resulting expressions scalars (24 and $N$, for our dataset $N$ will be 43).\n",
        "\n",
        "Show that $L(C|\\lambda)$ is a convex function of the coefficients $\\lambda$ on the domain $\\lambda \\in \\mathbb{R}^{24}_{++}$.\n",
        "\n",
        "(b) The log-likelihood function $L$ can be minimized to find the maximum likelihood estimate for the $\\lambda$ coefficients. Formulate this constrained optimization problem in `CVX`\n",
        "and solve it for the NYC crashes dataset, that is solve:\n",
        "\n",
        "$$\n",
        "\\min_{\\lambda} L(C|\\lambda) \\\\\n",
        "\\lambda \\in \\mathbb{R}^{24}_{+}\n",
        "$$\n",
        "\n",
        " Make a plot of the $\\lambda$ coefficients\n",
        "\n",
        "### Problem 4(a) and 4(b) Solution\n"
      ],
      "id": "38cec91f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# load packages\n",
        "import cvxpy as cp\n",
        "import pandas as pd\n",
        "\n",
        "# extract data\n",
        "crash_url = 'https://media.githubusercontent.com/media/georgehagstrom/DATA609Spring2025/refs/heads/main/website/assignments/labs/labData/manhattan_crashes.csv'\n",
        "\n",
        "crash_data = pd.read_csv(crash_url)\n",
        "\n",
        "# define variables\n",
        "C = crash_data.values\n",
        "N, T = C.shape\n",
        "\n",
        "# Define the optimization variable (lambda) which represents the rate parameters for each hour\n",
        "lambda_var = cp.Variable(T, pos=True)  # 24 variables for each hour\n",
        "\n",
        "# Define the log-likelihood function\n",
        "log_likelihood = N * cp.sum(lambda_var) - cp.sum(C * cp.log(lambda_var))\n",
        "\n",
        "# Define the objective function (minimize the negative log-likelihood)\n",
        "objective = cp.Minimize(log_likelihood)\n",
        "\n",
        "# Formulate the problem\n",
        "problem = cp.Problem(objective)\n",
        "\n",
        "# Solve the problem\n",
        "problem.solve()\n",
        "\n",
        "# Get the optimal values for lambda\n",
        "lambda_opt = lambda_var.value\n",
        "\n",
        "# Print the result\n",
        "print(\"Optimal lambda values:\", lambda_opt)\n",
        "\n",
        "# Plot the lambda values\n",
        "plt.plot(np.arange(T), lambda_opt, marker='o')\n",
        "plt.xlabel(\"Hour of the Day\")\n",
        "plt.ylabel(\"Estimated Crash Rate (lambda)\")\n",
        "plt.title(\"Estimated Crash Rate for Each Hour of the Day\")\n",
        "plt.grid(True)\n",
        "plt.show()"
      ],
      "id": "b9aca7ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "(c) It would be reasonable to expect that the rate of crashes in two adjacent hours should be similar, i.e. the observation that there has been a crash at 3:01PM should influence the estimate of the rate of crashes between 2:00PM and 3:00PM in addition to between 3:00PM and 4:00PM. \n",
        "\n",
        "One way to implement this is through the following regularization term, which applies a penalty proportional to the square of the difference between $\\lambda_i$ and $\\lambda_{i+1}$:\n",
        "\n",
        "$$\n",
        "L_{pen}(C|\\lambda,\\rho) = L(C|\\lambda) + \\rho\\left( \\sum_{i=1}^{23} (\\lambda_i-\\lambda_{i-1})^2 + (\\lambda_0-\\lambda_{23})^2\\right)\n",
        "$$\n",
        "\n",
        "Assuming that $\\rho>0$, show that $L_{pen}(C|\\lambda)$ is a convex function on $\\mathbb{R}^{24}_{++}$ \n",
        "\n",
        "### Problem 4(c) Solution\n"
      ],
      "id": "e827e168"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define the regularization term (penalty for difference between adjacent hours)\n",
        "S = np.zeros((T, T))  # T x T matrix for differences between adjacent lambda values\n",
        "for i in range(T):\n",
        "    if i == 0:\n",
        "        S[i, i] = 1\n",
        "        S[i, T-1] = -1\n",
        "    else:\n",
        "        S[i, i] = 1\n",
        "        S[i, i-1] = -1\n",
        "\n",
        "S = cp.Constant(S)  # Convert to a CVXPY constant\n",
        "\n",
        "# Define the regularization penalty\n",
        "rho = cp.Parameter(nonneg=True)  # Regularization parameter rho\n",
        "regularization = rho * cp.sum_squares(S @ lambda_var)\n",
        "\n",
        "# Define the objective function with the regularization term\n",
        "regularized_objective = cp.Minimize(log_likelihood + regularization)\n",
        "\n",
        "# Formulate the problem\n",
        "regularized_problem = cp.Problem(regularized_objective)\n",
        "\n",
        "# Solve the problem for different values of rho\n",
        "rho_values = [0.1, 1, 10, 100]\n",
        "for rho_val in rho_values:\n",
        "    rho.value = rho_val\n",
        "    regularized_problem.solve()\n",
        "    \n",
        "    # Plot the lambda values for each rho\n",
        "    plt.plot(np.arange(T), lambda_var.value, label=f\"rho = {rho_val}\")\n",
        "\n",
        "plt.xlabel(\"Hour of the Day\")\n",
        "plt.ylabel(\"Estimated Crash Rate (lambda)\")\n",
        "plt.title(\"Regularized Estimated Crash Rates for Different Rho Values\")\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()"
      ],
      "id": "10346668",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "(d) Formulate the regularized maximum likelihood problem:\n",
        "\n",
        "$$\n",
        "\\min_{\\lambda} L_{pen}(C|\\lambda,\\rho) \\\\\n",
        "\\lambda \\in \\mathbb{R}^{24}_{+} \\\\\n",
        "$$\n",
        "\n",
        "and solve it using `CVX`. Solve it for a range of positive values $\\rho$ such that for your smallest values the solution appears like your solution to (b) and for your largest values the $\\lambda$ show much less variation over time.\n",
        "\n",
        "### Problem 4(d) Solution\n"
      ],
      "id": "420dc693"
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Hint: There are many ways to implement this penalty term in `cvx`. A way that you might find useful is to define a matrix $S$ where $S_{ii} = 1$, $S_{i,i-1} = -1$ for $i>1$ and $S_{1,24}=-1$, with $S=0$ for all other entries:\n",
        "\n",
        "Then $S\\lambda = \\begin{bmatrix} [(\\lambda_1 - \\lambda_{24}) & (\\lambda_2-\\lambda_1) & \\cdots & (\\lambda_{24}-\\lambda_{23}) \\end{bmatrix}^T$, and you can\n",
        "use `cvx.square` and `cvx.sum` to construct the objective. "
      ],
      "id": "04cf6d0a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/eddiexuexia/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}