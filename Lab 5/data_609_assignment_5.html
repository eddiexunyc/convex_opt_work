<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Eddie Xu">

<title>DATA 609 - Homework 5: Disciplined Convex Programming and Data Fitting</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="data_609_assignment_5_files/libs/clipboard/clipboard.min.js"></script>
<script src="data_609_assignment_5_files/libs/quarto-html/quarto.js"></script>
<script src="data_609_assignment_5_files/libs/quarto-html/popper.min.js"></script>
<script src="data_609_assignment_5_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="data_609_assignment_5_files/libs/quarto-html/anchor.min.js"></script>
<link href="data_609_assignment_5_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="data_609_assignment_5_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="data_609_assignment_5_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="data_609_assignment_5_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="data_609_assignment_5_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">DATA 609 - Homework 5: Disciplined Convex Programming and Data Fitting</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Eddie Xu </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="instructions" class="level2">
<h2 class="anchored" data-anchor-id="instructions">Instructions</h2>
<p>Please submit a .qmd file along with a rendered pdf to the Brightspace page for this assignment. You may use whatever language you like within your qmd file, I recommend python, julia, or R.</p>
</section>
<section id="problem-1-penalty-function-approximations-modified-from-exercise-4-in-cvx-book-extended-exercises" class="level2">
<h2 class="anchored" data-anchor-id="problem-1-penalty-function-approximations-modified-from-exercise-4-in-cvx-book-extended-exercises">Problem 1: Penalty Function Approximations (Modified from Exercise 4 in CVX Book Extended Exercises)</h2>
<p>Consider the approximation problem: <span class="math display">\[
\min_{\mathbf{x}\in\mathbb{R}^n} \phi\left(A\mathbf{x}-\mathbf{b}\right),
\]</span></p>
<p>where <span class="math inline">\(A\)</span> is an <span class="math inline">\(m\times n\)</span> matrix, <span class="math inline">\(x\in\mathbb{R}^n\)</span>, and <span class="math inline">\(\phi: \mathbb{R}^m\to\mathbb{R}\)</span> is a convex penalty function measuring the approximation error, and <span class="math inline">\(\mathbf{b}\)</span> is an <span class="math inline">\(m\)</span>-vector.</p>
<p>The purpose of this exercise is for you to implement several different penalty functions in <code>CVX</code> and study how the resulting coefficients <span class="math inline">\(x\)</span> from each penalty function differ, as a means of building intuition about penalty functions.</p>
<p>You will use the following penalty functions:</p>
<ol type="a">
<li><span class="math inline">\(\phi(\mathbf{y}) = \|y\|_2\)</span>, the standard Euclidean norm</li>
<li><span class="math inline">\(\phi(\mathbf{y}) = \|y\|_1\)</span>, the <span class="math inline">\(L_1\)</span> norm. This is often referred to as the Lasso</li>
<li><span class="math inline">\(\phi(\mathbf{y}) = \sum_{k=1}^{m/2} |y_{r_k}|\)</span>, where <span class="math inline">\(r_k\)</span> is the index of the component with the <span class="math inline">\(k\)</span>th largest absolute value. This is like the Lasso, but where we only count the terms with their error in the top half, i.e.&nbsp;<span class="math inline">\(y_{r_1}\)</span> is the <span class="math inline">\(y\)</span> with largest absolute value, <span class="math inline">\(y_{r_2}\)</span> is the <span class="math inline">\(y\)</span> with second largest absolute value, etc.</li>
<li><span class="math inline">\(\phi(\mathbf{y}) = \sum_{k=1}^m h(y_k)\)</span>, where <span class="math inline">\(h(y)\)</span> is the Huber penalty, defined by:</li>
</ol>
<p><span class="math display">\[
h(u) = \begin{cases} u^2,\, |u|\leq M \\
M(2|u|-M),\, |u|\geq M,
\end{cases}
\]</span> For this problem use <span class="math inline">\(M=0.2\)</span></p>
<ol start="5" type="a">
<li><span class="math inline">\(\phi(\mathbf{y}) = \sum_{k=1}^m h(y_k)\)</span>, where <span class="math inline">\(h\)</span> is the log-barrier penalty, defined by: <span class="math display">\[
h(u) = -\log(1-u^2),\quad \mathbf{dom}(h) = \{u |\quad|u|&lt; 1 \}
\]</span></li>
</ol>
<p>Generate data <span class="math inline">\(A\)</span> and <span class="math inline">\(\mathbf{b}\)</span> as follows:</p>
<ul>
<li><span class="math inline">\(m=200\)</span></li>
<li><span class="math inline">\(n=100\)</span></li>
<li><span class="math inline">\(A_{ij} \sim \mathrm{Normal}(\mu = 0,\sigma = 1)\)</span>, each element normally distributed with mean 0 and standard deviation 1</li>
<li>Intialize <span class="math inline">\(b\)</span> as using a normal distribution of mean <span class="math inline">\(\mu=0\)</span> and <span class="math inline">\(\sigma=1\)</span>, and then normalize <span class="math inline">\(b\)</span> so that all of its entries have absolute value less than <span class="math inline">\(1\)</span> by doing something like:
<ul>
<li><span class="math inline">\(b_i \sim Normal(\mu = 0,\sigma = 1)\)</span></li>
<li>and then: <code>b=b/(1.01 max(abs(b)))</code></li>
</ul></li>
</ul>
<p>This is to make sure the <code>log-barrier</code> function as a non-empty domain.</p>
<p>Visualize the distribution of errors (using a tool like a histogram or density plot) for each of these penalty function formulations and comment on the differences that you observe. Each penalty function prioritizes a errors differently, how do these priorities manifest in the distribution of residuals.</p>
<p>Some hints for selected parts:</p>
<ol type="a">
<li>Technically this is a least squares problem, you can solve it using Least-Sqares formula or <code>CVX</code></li>
<li>Use <code>norm(y,1)</code></li>
<li>Use <code>norm_largest()</code></li>
<li>Use <code>huber()</code></li>
<li>The extended exercises claimed that the <code>log-barrier</code> objective needed to be reformulated to use the geometric mean, but I found that this problem worked perfectly well with a straightforward implementation. I suspect that the <code>CVX</code> software was upgraded to better handle <code>log</code> and <code>exp</code> objecties since this exercise was developed.</li>
</ol>
</section>
<section id="problem-2-fitting-censored-data-extended-exercises-6.13-in-cvx-book" class="level2">
<h2 class="anchored" data-anchor-id="problem-2-fitting-censored-data-extended-exercises-6.13-in-cvx-book">Problem 2: Fitting Censored Data (Extended Exercises 6.13 in CVX Book)</h2>
<p>In some experiments there are two kinds of measurements or data available: The usual ones, in which you get a number (say), and censored data, in which you don’t get the specific number, but are told something about it, such as a lower bound.</p>
<p>A classic example is a study of lifetimes of a set of subjects (say, laboratory mice, devices undergoing reliability testing, or people in a long-term, longitudinal study). For those who have died by the end of data collection, we get the lifetime.</p>
<p>For those who have not died by the end of data collection, we do not have the lifetime, but we do have a lower bound, i.e., the length of the study. In statistics, we call this type of data <code>right-censored</code> data, meaning that we do not have the exact values in the right tail of the distribution. The data points that are not present are called the censored data values.</p>
<p>We wish to fit a set of data points, <span class="math inline">\(\left((\mathbf{x}_1,y_1), \cdots, (\mathbf{x}_k,y_k)\right)\)</span>, with <span class="math inline">\(\mathbf{x}_k \in \mathbb{R}^n\)</span> and <span class="math inline">\(y_k\in\mathbb{R}\)</span>, with a linear model of the form <span class="math inline">\(y ≈ \mathbf{c}^T \mathbf{x}\)</span>. The vector <span class="math inline">\(\mathbf{c} \in \mathbf{R}^n\)</span> is the model parameter, which we want to choose. We will use a least-squares criterion, i.e., choose <span class="math inline">\(\mathbf{c}\)</span> to minimize:</p>
<p><span class="math display">\[
J = \sum_{i=1}^k \left(y_i - \mathbf{c}^T\mathbf{x}_i\right)^2
\]</span></p>
<p>Here is the tricky part: some of the values of <span class="math inline">\(y_i\)</span> are censored; for these entries, we have only a (given) lower bound.</p>
<p>We will re-order the data so that <span class="math inline">\(y_1 , \cdots , y_m\)</span> are given (i.e., uncensored), while <span class="math inline">\(y_{m+1} , \cdots y_k\)</span> are all censored, i.e., unknown, but larger than D, a given number. All the values of <span class="math inline">\(\mathbf{x}_i\)</span> are known.</p>
<ol type="a">
<li><p>Explain how to find <span class="math inline">\(\mathbf{c}\)</span> (the model parameter) and <span class="math inline">\(y_{m+1} ,\cdots , y_k\)</span> (the censored data values) that minimize <span class="math inline">\(J\)</span>. Hint: should the censored data be variables or parameters?</p></li>
<li><p>Carry out the method of part (a) on the data values in the file <a href="https://github.com/georgehagstrom/DATA609Spring2025/blob/main/website/assignments/labs/labData/censored_dict.json">censored_dict.json</a>. You can process this file in <code>R</code> using <code>fromJSON</code> in the <code>jsonlite</code> package or in python using the <code>json</code> library and:</p></li>
</ol>
<div id="cd55e6af" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'censored_dict.json'</span>, <span class="st">'r'</span>) <span class="im">as</span> fp:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> json.load(fp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Report <span class="math inline">\(\hat{\mathbf{c}}\)</span>, the value of <span class="math inline">\(\mathbf{c}\)</span> found using this method.</p>
<p>Also find <span class="math inline">\(\hat{\mathbf{c}_{ls}}\)</span> , the least-squares estimate of <span class="math inline">\(\mathbf{c}\)</span> obtained by simply ignoring the censored data samples, i.e., the least-squares estimate based on the data <span class="math inline">\((\mathbf{x}_1 , y_1 ), \cdots (\mathbf{x}_m , y_m )\)</span>.</p>
<p>The data file contains <span class="math inline">\(\mathbf{c}_{\mathrm{true}}\)</span> , the true value of <span class="math inline">\(\mathbf{c}\)</span>, in the vector <span class="math inline">\(\mathbf{c}_{\mathrm{true}}\)</span>. Use this to give the two relative errors:</p>
<p><span class="math display">\[
\frac{\|\mathbf{c}_{\mathrm{true}}- \hat{\mathbf{c}}\|_2^2}{\|\mathbf{c}_{\mathrm{true}}\|_2^2},\quad
\frac{\|\mathbf{c}_{\mathrm{true}}- \hat{\mathbf{c}_{ls}}\|_2^2}{\|\mathbf{c}_{\mathrm{true}}\|_2^2}
\]</span></p>
</section>
<section id="problem-3-robust-logistic-regression-exercise-6.29-in-the-cvx-book-extended-exercises" class="level2">
<h2 class="anchored" data-anchor-id="problem-3-robust-logistic-regression-exercise-6.29-in-the-cvx-book-extended-exercises">Problem 3: Robust Logistic Regression (Exercise 6.29 in the CVX Book extended exercises)</h2>
<p>We are given a data set <span class="math inline">\(\mathbf{x}_i \in \mathbb{R}^d\)</span> , <span class="math inline">\(y_i \in \{−1, 1\}, i = 1, \cdots , n\)</span>. We seek a prediction model <span class="math inline">\(\hat{y} = \mathrm{sign}(\theta^T \mathbf{x})\)</span>, where <span class="math inline">\(\theta \in \mathbb{R}^d\)</span> is the model parameter.</p>
<p>In logistic regression, <span class="math inline">\(\theta\)</span> is chosen as the minimizer of the logistic loss:</p>
<p><span class="math display">\[
l(\theta) = \sum_{i=1}^n \log\left(1 + \exp\left(-y_i\theta^T\mathbf{x}_i\right)\right)
\]</span></p>
<p>which is a convex function of <span class="math inline">\(\theta\)</span>. Here <span class="math inline">\(\|\delta_i\|_{\infty} = \max_j |\delta_{ij}|\)</span>. Remember that each <span class="math inline">\(\delta_i\)</span> is a vector with length the same as <span class="math inline">\(\mathbf{x}_i\)</span>.</p>
<p>In robust regression, we take into account the idea that the feature vectors <span class="math inline">\(\mathbf{x}_i\)</span> are not known precisely. Specifically we imagine that each entry of each feature vector can vary by <span class="math inline">\(\pm\epsilon\)</span>, where <span class="math inline">\(\epsilon &gt; 0\)</span> is a given uncertainty level.</p>
<p>We define the worst-case logistic loss as:</p>
<p><span class="math display">\[
l_{wc}(\theta) = \sum_{i=1}^n \sup_{\|\delta_i\|_{\infty}\leq\epsilon}\log\left(1+\exp\left(-y_i\theta^T\left(\mathbf{x}_i+\delta_i\right)\right)\right)
\]</span></p>
<p>In words: we perturb each feature vector’s entries by up to <span class="math inline">\(\epsilon\)</span> in such a way as to make the logistic loss as large as possible. Each term is convex, since it is the supremum of a family of convex functions of <span class="math inline">\(\theta\)</span>, and so <span class="math inline">\(l_{wc}(\theta)\)</span> is a convex function of <span class="math inline">\(\theta\)</span>.</p>
<p>In robust logistic regression, we choose <span class="math inline">\(\theta\)</span> to minimize <span class="math inline">\(l_{wc}(\theta)\)</span>.</p>
<ol type="a">
<li>Explain how to carry out robust logistic regression by solving a single convex optimization problem in disciplined convex programming (DCP) form. Justify any change of variables or introduction of new variables. Explain why solving the problem you propose also solves the robust logistic regression problem.</li>
</ol>
<p>Hint: <span class="math inline">\(log(1 + exp(u)))\)</span> is monotonic in u.</p>
<ol start="2" type="a">
<li>Fit a standard logistic regression model (i.e., minimize <span class="math inline">\(l(\theta)\)</span>), and also a robust logistic regression model (i.e., minimize <span class="math inline">\(l_{wc}(\theta)\)</span>), using the data given in <a href="https://github.com/georgehagstrom/DATA609Spring2025/blob/main/website/assignments/labs/labData/rob_regression.csv">rob_regression.csv</a> and <a href="https://github.com/georgehagstrom/DATA609Spring2025/blob/main/website/assignments/labs/labData/rob_regression_test.csv">rob_regression_test.csv</a>.</li>
</ol>
<p>The <span class="math inline">\(\mathbf{x}_i\)</span>s are provided as the rows of an <span class="math inline">\(n \times d\)</span> matrix named <span class="math inline">\(X\)</span> (these are the variables of the data frame named “X_1, X_2, …”). The <span class="math inline">\(y_i\)</span>s are provided as the entries of a <span class="math inline">\(n\)</span>-vector named <span class="math inline">\(y\)</span> (the first column in the data frame).</p>
<p>The file also contains a test data set, <span class="math inline">\(X_{\mathrm{test}}\)</span>, <span class="math inline">\(y_{\mathrm{test}}\)</span>. Give the test error rate (i.e., fraction of test set data points for which <span class="math inline">\(\hat{y}= y\)</span>) for the logistic regression and robust logistic regression models.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>