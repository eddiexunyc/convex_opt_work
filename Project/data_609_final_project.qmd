---
title: "DATA 609: Final Project - A Simple Convex Optimization on Regulatory Financial Reporting"
format: html
editor: source
author: Eddie Xu
---

## Introduction

All financial institutions are required to report their financial data in accordance with multiple regulatory frameworks such as Basel III and Dodd Frank Act. Due to the complexities with some of the framework, it can be challenging for some financial companies, particularly smaller regional or community banks, to maximize their returns while ensure that they are to be in regulatory compliance on limited resources and times. Because of that, it can cause potential reporting errors and may lead to financial institutions being penalized with fines of millions dollars and may have a significant impact on the financial market.

### Abstract

For this project, the goal is to leverage convex optimization applications for a simple regulatory financial reporting problem. Specifically, the optimal allocation of a proposed bank's capital across different assets (cash, bonds, stocks, etc) will be determined in order to maximize returns and minimize the market risks while ensuring compliance with regulatory capital requirements under the Basel III. A proposed bank and its capital will be designed 

## Data Exploratory Analysis

For data sources, this project will utilizes public available data based on the 2020-2025 data including yfinance and quantstats. The S&P 500 will be used to reflect the overall stock performance in the US stock market and the I-bonds will be used to reflect the overall treasury bond performance.

### Load Dependencies

```{python}
# load dependencies
import numpy as np
import pandas as pd
import cvxpy as cp
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt
import warnings
warnings.filterwarnings("ignore")

# data financial libraries
import yfinance as yf
import quantstats as qs
```

### Data Pulling 

```{python}
# pull data for S&P 500 and Treasury from Yahoo Finance
ticker_list = ['SPY', 'TLT']
financial_data = yf.download(ticker_list, start = '2020-01-01', end ='2025-01-01', auto_adjust=False, group_by='ticker')

financial_data
```

### Data Wrangling

```{python}
# change the multiIndex format to single column data frame for ease of usage
fin_tidy_data = financial_data.stack(level=0).reset_index()
fin_tidy_data = fin_tidy_data.rename(columns={'level_1': 'Ticker'})
fin_tidy_data['Date'] = pd.to_datetime(fin_tidy_data['Date'])
fin_tidy_data = fin_tidy_data.sort_values(by=['Ticker', 'Date'])

# calculate simple returns and log returns per ticker
fin_tidy_data['Return'] = fin_tidy_data.groupby('Ticker')['Adj Close'].pct_change()
fin_tidy_data['Log_Return'] = np.log1p(fin_tidy_data['Return'])

# calculate Value at Risk (VaR) per ticker and merge VaR back into the main data
temp = fin_tidy_data.set_index('Date')
var_values = temp.groupby('Ticker')['Return'].apply(qs.stats.var)
fin_tidy_data = fin_tidy_data.merge(var_values.rename('Value_at_Risk'), on='Ticker')

print(fin_tidy_data.head())
```

### Data Visualization

Based on the historical performance in terms of the adjusted closing price on both tickers, it shows that they were doing fairly well in the last 5 years.

```{python}
# pivot the date for line plot
adj_close = fin_tidy_data.pivot(index='Date', columns = 'Ticker', values = 'Adj Close').reset_index()

# plot the adjusted closing price
plt.plot(adj_close['Date'], adj_close['SPY'], label = 'SPY',linestyle='-', color='cornflowerblue')
plt.plot(adj_close['Date'], adj_close['TLT'], label = 'TLT',linestyle='-', color='green')

plt.title("Adjusted Closing Price over Time")
plt.legend()
plt.show()
```

## Convex Optimization

The portfolio will be using the _Markowitz Portfolio Optimization_ to construct a set of portfolios that aim to achieve target expected rates of return while minimizing risk set by the 

```{python}
# filter data into training (2020-2023) and testing (2024-2025) periods
train_period = fin_tidy_data[(fin_tidy_data['Date'] >= '2020-01-01') & (fin_tidy_data['Date'] <= '2023-12-31')]
test_period = fin_tidy_data[(fin_tidy_data['Date'] > '2023-12-31')]

# convert the data with the log return
train_data = train_period.pivot(index='Date', columns='Ticker', values='Log_Return')
test_data = test_period.pivot(index='Date', columns='Ticker', values='Log_Return')

train_data
```

```{python}
# calculate the annual mean and covariance matrix
mu = np.exp(0.5 * train_data.sum()) - 1
gamma = train_data.cov().values

# define variables
r_targets = [1.05, 1.10, 1.20]
optimal_weights = {}
portfolio_cum_returns_train = {}
portfolio_cum_returns_test = {}

for r in r_targets:
    # define the variable 
    w = cp.Variable(len(mu))

    # define the objective function: 0.5 * w^T * Gamma * w
    objective = cp.Minimize(0.5 * cp.quad_form(w, gamma))

    # define the constraints
    constraints = [cp.sum(w) == 1, w.T @ mu == r, w >= 0]

    # solve the problem
    problem = cp.Problem(objective, constraints)
    problem.solve()

    # store the optimal weight
    optimal_weights[r] = w.value

    # calculate portfolio returns for training period
    portfolio_returns_train = train_data.dot(w.value)
    portfolio_cum_returns_train[r] = np.cumprod(1 + portfolio_returns_train)

    # calculate portfolio returns for testing period
    portfolio_returns_test = test_data.dot(w.value)
    portfolio_cum_returns_test[r] = np.cumprod(1 + portfolio_returns_test)

# plot cumulative returns for training and testing periods
plt.figure(figsize=(12, 6))

for r in r_targets:
    plt.plot(portfolio_cum_returns_train[r], label=f'Training: r={r}')

plt.title('Cumulative Portfolio Value for Different Target Returns (Training)')
plt.legend()
plt.xlabel('Days')
plt.ylabel('Cumulative Portfolio Value')
plt.show()

plt.figure(figsize=(12, 6))

for r in r_targets:
    plt.plot(portfolio_cum_returns_test[r], label=f'Testing: r={r}')

plt.title('Cumulative Portfolio Value for Different Target Returns (Testing)')
plt.legend()
plt.xlabel('Days')
plt.ylabel('Cumulative Portfolio Value')
plt.show()
```

After the problem is trained, the target return will be set to 20% and see the optimal portfolio while maintaining the requirement.

```{python}
# set the target return
r = 0.20  

# define the lambda range
lambda_values = np.logspace(-1, 1, 10) 

# define dicts for storing results
optimal_weights_ridge = {}
portfolio_cum_returns_train_ridge = {}
portfolio_cum_returns_test_ridge = {}


for lam in lambda_values:
    # define the variable
    w = cp.Variable(len(mu))

    # define the objective function: 0.5 * w^T * (Gamma + lambda * I) * w
    objective = cp.Minimize(0.5 * cp.quad_form(w, cp.psd_wrap(gamma + lam * np.eye(len(mu)))))

    # define the constraints
    constraints = [cp.sum(w) == 1, w.T @ mu == r, w >= 0]

    # define the optimization problem
    problem = cp.Problem(objective, constraints)

    # Solve the problem
    problem.solve()

    # store the optimal weights
    optimal_weights_ridge[lam] = w.value

    # calculate portfolio returns for training data
    portfolio_returns_train = train_data.dot(w.value)
    portfolio_cum_returns_train_ridge[lam] = np.cumprod(1 + portfolio_returns_train)

    # calculate portfolio returns for testing data
    portfolio_returns_test = test_data.dot(w.value)
    portfolio_cum_returns_test_ridge[lam] = np.cumprod(1 + portfolio_returns_test)

# plot the lamda training period
for lam in lambda_values:
    plt.plot(portfolio_cum_returns_train_ridge[lam], label=f'Training: 位={lam:.2f}')

#plt.title('Cumulative Portfolio Value with Ridge Regularization (位 values - Training)')
plt.legend()
plt.xlabel('Days')
plt.ylabel('Cumulative Portfolio Value')
plt.show()

# plot the lamda testing period
for lam in lambda_values:
    plt.plot(portfolio_cum_returns_test_ridge[lam], label=f'Testing: 位={lam:.2f}')

plt.title('Cumulative Portfolio Value with Ridge Regularization (位 values - Testing)')
plt.legend()
plt.xlabel('Days')
plt.ylabel('Cumulative Portfolio Value')
plt.show()
```

