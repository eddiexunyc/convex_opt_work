{
  "cells": [
    {
      "cell_type": "raw",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Untitled\"\n",
        "format: html\n",
        "---\n",
        "\n",
        "---"
      ],
      "id": "c8b4f864"
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "title: \"Homework 1: Introduction to Optimization and Least Squares\"\n",
        "format: html \n",
        "editor: source\n",
        "---\n",
        "\n",
        "\n",
        "## Instructions\n",
        "\n",
        "Please submit a .qmd file along with a rendered pdf to the Brightspace page for this assignment. You may use whatever language you like within your qmd file,\n",
        "I recommend python, julia, or R. \n",
        "\n",
        "## Problem 1: Gradient Descent\n",
        "\n",
        "\n",
        "(a) Consider the mathematical function defined on $f: \\mathbb{R}^2\\,\\to\\, \\mathbb{R}$:\n",
        "\n",
        "$$\n",
        "f(x,y) = (x-1)^2 + (y+2)^2,\n",
        "$$\n",
        "\n",
        "Find the single critical point of this function and show that it is a local minimum (in this case, this will also be a global minimum).\n",
        "\n",
        "(b) Now consider a new objective function that depends on a parameter $b$:\n",
        "$$\n",
        "f(x,y) = x^2 + by^2\n",
        "$$\n",
        "\n",
        "Here we will look at two different values of $b$, $b=3$ and $b=10$. The global minimum of this function occurs at the point $x^* = 0$, $y^*=0$ no matter what the value of $b$. \n",
        "Suppose that we didn't know this and wanted to find the minimum of this function using gradient descent instead of direct calculation.\n",
        "\n",
        "- First write code to perform the gradient descent algorithm, that is perform the iteration:\n",
        "$$\n",
        "\\mathbf{v}_{n+1} = \\mathbf{v}_n - k \\nabla f(\\mathbf{v}_n),\n",
        "$$\n",
        "\n",
        "where the vector $\\mathbf{v} = \\begin{bmatrix} x & y\\end{bmatrix}^T$ and $k$ is the learning rate.\n",
        "\n",
        "- Then test the performance of your algorithm as a function of the learning rates $k$ by performing 100 iterations of the algorithm for 100 values of $k$ equally spaced between $k=0.01$ and $k=0.3$. Start with an initial guess of $\\mathbf{v}_0 = \\begin{bmatrix} b & 1\\end{bmatrix}^T$. Do this for $b=3$ and $b=10$. Make separate plots for $b=3$ and $b=10$ of the log base 10 of the error (in this case it is $\\sqrt{x_{100}^2+y_{100}^2}$) for the final value of the iteration versus the value of $k$. How does learning rate relate to the final value of the error? For which value of $b$ does the algorithm have the ability to converge fastest (have the lowest value of the error at the end)?\n",
        "\n",
        "Problem 1 Solution\n"
      ],
      "id": "f932c20d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# load dependencies\n",
        "import sympy as sp\n",
        "from scipy.optimize import minimize\n",
        "import numpy as np\n",
        "\n",
        "## Part A \n",
        "# define the function\n",
        "x, y = sp.symbols('x y')\n",
        "formula = (x-1)**2 + (y+2)**2\n",
        "\n",
        "# find the critical point for the function\n",
        "df_x = sp.diff(formula, x)\n",
        "critical_point_x = sp.solve(df_x, x)\n",
        "\n",
        "df_y = sp.diff(formula, y)\n",
        "critical_point_y = sp.solve(df_y, y)\n",
        "\n",
        "print(f'The critical point of x: {critical_point_x} and y: {critical_point_y}')\n",
        "\n",
        "# find the local minimum \n",
        "df_dx = sp.diff(df_x, x)\n",
        "critical_point_x2 = df_dx.subs(x, critical_point_x[0])\n",
        "print(f'{critical_point_x2} is positive and it is the local minimum')\n",
        "\n",
        "## Part B\n",
        "# define the gradient descent algorithm\n",
        "def grad_descent(start_x, start_y, learning_rate, num_iterations):\n",
        "    x = start_x\n",
        "    y = start_y"
      ],
      "id": "a7a730c6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note: For some combinations of $k$ and $b$, the algorithm won't converge to the right answer, i.e. the error will grow with time. To make your plot easier to read, don't plot the error for iterations that didn't converge. \n",
        "\n",
        "- As $k$ increases, for one or both values of $b$, you will observe a point where the trend of final error versus learning rate reverses direction. Pick a value of $k$ very close to the point where this occurs, and make a contour plot\n",
        "of the function $f$ and the trajectory of the iterations for the gradient descent algorithm for that value of $k$ superimposed over the contour plot. What do you observe?\n",
        "\n",
        "Note: The differences that you observe here are a special case of a more general phenomenon: the speed of convergence of gradient descent \n",
        "depends on something called the _condition number_ of the\n",
        "_Hessian_ matrix (the matrix of the 2nd order partial derivatives) of the target function. The condition number for a symmetric matrix is just the ratio of the largest to smallest eigenvalues, in this case the condition number is $b$ (or 1/$b$). \n",
        "Gradient descent performs worse and worse the larger the condition number (and large condition numbers are problematic for a wide variety of other numerical methods).\n",
        "\n",
        "\n",
        "## Problem 2: Solving Least Squares Problems\n",
        "\n",
        "Generate a random $20\\times 10$ matrix $A$ and a random 20-vector $b$ (use a Gaussian distribution).\n",
        "Then, solve the least squares problem:\n",
        "$$\n",
        "\\min_{\\mathbf{x}\\in \\mathbb{R}^{10}} \\|A\\mathbf{x} - \\mathbf{b}\\|^2\n",
        "$$\n",
        "in the following ways:\n",
        "\n",
        "(a) Multiply $\\mathbf{b}$ by the Morse-Penrose Pseudoinverse $A^+$.\n",
        "\n",
        "(b) Use built in functions to solve the least squares problem (i.e. in python numpy.lstsq, in R lm, and in Julia the backslash operator). \n",
        "\n",
        "(c) Using the $QR$ factorization of $A$. This factorization\n",
        "rewrites $A$ as:\n",
        "$$\n",
        "A = \\begin{bmatrix} Q & 0\\end{bmatrix} \\begin{bmatrix} R & 0 \\end{bmatrix}^T,\n",
        "$$\n",
        "where $Q$ is an orthonormal matrix and $R$ is upper triangular. The\n",
        "least squares solution equals:\n",
        "$$\n",
        "\\mathbf{x} = R^{-1}Q^T\\mathbf{b}\n",
        "$$\n",
        "\n",
        "(d) Verify that each of these solutions are nearly equal and that \n",
        "the residuals $A\\mathbf{x}-\\mathbf{b}$ are orthogonal to the vector\n",
        "$A\\mathbf{x}$\n",
        "\n",
        "Problem 2 Solution\n"
      ],
      "id": "986ebba1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# load dependencies\n",
        "import numpy as np\n",
        "\n",
        "## Part A\n",
        "# define the matrix\n",
        "a = np.random.randn(10, 20)\n",
        "b = np.random.randn(20)\n",
        "\n",
        "# multiply b by the Morse-Penrose Pseudoinverse a\n",
        "x_normal = b @ np.linalg.pinv(a)\n",
        "print('This is the normal solution.')\n",
        "print(x_normal)\n",
        "\n",
        "## Part B\n",
        "# need to transpose a to get the least squares problem to work\n",
        "x_lstsq = np.linalg.lstsq(a.T, b)[0]\n",
        "print('This is the least squares problem solution.')\n",
        "print(x_lstsq)\n",
        "\n",
        "## Part C\n",
        "x_qr = "
      ],
      "id": "3771cc2e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Problem 3: Iterative Solutions to Least Squares\n",
        "\n",
        "Although the pseudoinverse provides an exact formula for the least\n",
        "squares solutions, there are some situations in which using the exact\n",
        "solution is computationally difficult, particularly when the matrix $A$ \n",
        "and vector $\\mathbf{b}$ have a large number of entries. In this case,\n",
        "$AA^T$, which is an $m\\times m$ matrix if $A$ is $m\\times n$, may require an enormous amount of memory. In these cases it may be better to use an\n",
        "approximate solution instead of the exact formula. There are many\n",
        "different approximate methods for solving least squares problems, \n",
        "here we will use an iterative method developed by Richardson.\n",
        "\n",
        "This method begins with an initial guess $\\mathbf{x}^{(0)} = 0$ \n",
        "and calculates successive approximations as follows:\n",
        "\n",
        "$$\n",
        "    \\mathbf{x}^{(k+1)} = \\mathbf{x}^{(k)} - \\mu A^T\\left(A\\mathbf{x}^{(k)}-\\mathbf{b}\\right)\n",
        "$$\n",
        "\n",
        "Here $\\mu$ is a positive paramter that has a similar interpretation to the learning rate for \n",
        "gradient descent. A choice that guarantees convergence is $\\mu \\leq \\frac{1}{\\|A\\|}$. The iteration is terminated when the change in the residual\n",
        "$\\|A^T(Ax^{(k)} âˆ’ b)\\|$ after successive steps is below a user determined threshold, which indicates that the least squares optimality conditions are nearly satisfied.\n",
        "\n",
        "(a) Suppose that $\\mathbf{x}$ is a solution to the least squares problem:\n",
        "$$\n",
        "\\mathbf{x} = A^+\\mathbf{b}\n",
        "$$\n",
        "\n",
        "Show by substitution of the formula for the pseudoinverse that $\\mathbf{x}$ is a \\emph{fixed point} of the iteration scheme, i.e. that:\n",
        "$$\n",
        "\\mathbf{x} = \\mathbf{x} - \\mu A^T\\left(A\\mathbf{x}-\\mathbf{b}\\right)\n",
        "$$\n",
        "\n",
        "(b) Generate a random 20 Ã— 10 matrix $A$ and 20-vector $\\mathbf{b}$, and compute the least squares solution $\\mathbf{x} = A^+\\mathbf{b}$.\n",
        "Then run the Richardson algorithm with $\\mu = \\frac{1}{\\|A\\|^2}$ for\n",
        "500 iterations, and plot $\\|\\mathbf{x}^{(k)}-\\mathbf{x}\\|$ to verify\n",
        "that $\\mathbf{x}^{(k)}$ is converging to $\\mathbf{x}$\n",
        "\n",
        "Problem 3 Solution\n"
      ],
      "id": "8a8d400a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/eddiexuexia/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}